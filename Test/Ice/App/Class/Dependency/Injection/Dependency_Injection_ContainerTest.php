<?php

namespace Ice;

require_once dirname (__FILE__) . '/../../../../../../App/Class/Dependency/Injection/Container.php';

/**
 * Test class for Dependency_Injection_Container.
 * Generated by PHPUnit on 2011-12-23 at 09:59:19.
 */
class Dependency_Injection_ContainerTest extends \PHPUnit_Framework_TestCase
{

	/**
	 * @var Dependency_Injection_Container
	 */
	protected $object;

	/**
	 * Sets up the fixture, for example, opens a network connection.
	 * This method is called before a test is executed.
	 */
	protected function setUp ()
	{
		$this->object = new Dependency_Injection_Container;
	}

	/**
	 * Tears down the fixture, for example, closes a network connection.
	 * This method is called after a test is executed.
	 */
	protected function tearDown ()
	{

	}

	/**
	 * @todo Implement testGetClassInstance().
	 */
	public function testGetClassInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testGetInstance().
	 */
	public function testGetInstance ()
	{
		$real_class = 'Ice\\Mock';

		$test_object_instance = $this;
		$test_object_class = get_class ($test_object_instance);

		Loader::load('Mock');
		$test_class1 = new Mock;
		$test_class2 = new Mock;
		$test_class3 = new Mock;

		$this->object->pushInstance($real_class, $test_class1);

		// Теперь будет возвращаться заданный объект
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class)
		);
		// аналогично для класса
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class, $test_object_class)
		);
		// и для объекта
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class, $test_object_instance)
		);

		// Для первого тестового класса подменим
		$this->object->pushInstance(
			$real_class,
			$test_class2,
			$test_object_class
		);

		// в глобальном контексте остался прежний
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class)
		);
		
		// а для класса подъменится
		$this->assertSame(
			$test_class2,
			$this->object->getInstance ($real_class, $test_object_class)
		);
		// для объекта будет как для класса
		$this->assertSame(
			$test_class2,
			$this->object->getInstance ($real_class, $test_object_instance)
		);

		// Подмена для объекта
		$this->object->pushInstance(
			$real_class,
			$test_class3,
			$test_object_instance
		);

		// в глобальном контексте остался прежний
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class)
		);
		// для класса как во втором тесте
		$this->assertSame(
			$test_class2,
			$this->object->getInstance ($real_class, $test_object_class)
		);
		// для объекта изменится
		$this->assertSame(
			$test_class3,
			$this->object->getInstance ($real_class, $test_object_instance)
		);

		// Возвращаем в начальное состояние
		$this->object->popInstance($real_class, $test_object_instance);

		// в глобальном контексте остался $test_class1
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class)
		);
		// для класса $test_class2
		$this->assertSame(
			$test_class2,
			$this->object->getInstance ($real_class, $test_object_class)
		);
		// для объекта как для класса
		$this->assertSame(
			$test_class2,
			$this->object->getInstance ($real_class, $test_object_instance)
		);

		// Убираем для класса
		$this->object->popInstance($real_class, $test_object_class);

		// Теперь будет возвращаться заданный объект
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class)
		);
		// аналогично для класса
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class, $test_object_class)
		);
		// и для объекта
		$this->assertSame(
			$test_class1,
			$this->object->getInstance ($real_class, $test_object_instance)
		);

		$this->object->popInstance($real_class);

		// Теперь для класса ничего не задано, соответсвенно он будет содан
		$this->assertInstanceOf(
			$real_class,
			$this->object->getInstance ($real_class)
		);
		// аналогично для класса
		$this->assertInstanceOf(
			$real_class,
			$this->object->getInstance ($real_class, $test_object_class)
		);
		// и для объекта
		$this->assertInstanceOf(
			$real_class,
			$this->object->getInstance ($real_class, $test_object_instance)
		);

	}

	/**
	 * @todo Implement testGetObjectInstance().
	 */
	public function testGetObjectInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testGetPublicInstance().
	 */
	public function testGetPublicInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testGetNewInstance().
	 */
	public function testGetNewInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testGetRealClass().
	 */
	public function testGetRealClass ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPushClassInstance().
	 */
	public function testPushClassInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPushInstance().
	 */
	public function testPushInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPushObjectInstance().
	 */
	public function testPushObjectInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPushPublicInstance().
	 */
	public function testPushPublicInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPopClassInstance().
	 */
	public function testPopClassInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPopInstance().
	 */
	public function testPopInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPopObjectInstance().
	 */
	public function testPopObjectInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testPopPublicInstance().
	 */
	public function testPopPublicInstance ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

	/**
	 * @todo Implement testSetRealClass().
	 */
	public function testSetRealClass ()
	{
		// Remove the following lines when you implement this test.
		$this->markTestIncomplete (
				'This test has not been implemented yet.'
		);
	}

}

?>
